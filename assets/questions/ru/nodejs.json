{
    "1": {
        "question": "Что такое функция первого класса в JavaScript?",
        "answer": "Когда функции могут рассматриваться как любая другая переменная, тогда эти функции являются функциями первого класса. Многие другие языки программирования, например, Scala, Haskell и т. д., следуют этому, включая JS. Теперь из-за этого функцию можно передавать как параметр в другую функцию (обратный вызов), или функция может возвращать другую функцию (функция высшего порядка). map() и filter() - это функции высшего порядка, которые часто используются."
    },
    "2": {
        "question": "Что такое Node.js и как он работает?",
        "answer": "Node.js - это виртуальная машина, которая использует JavaScript в качестве языка сценариев и запускает движок JavaScript Chrome V8. По сути, Node.js основан на событийно-ориентированной архитектуре, где ввод-вывод выполняется асинхронно, что делает его легким и эффективным. Он используется также в разработке настольных приложений с популярным фреймворком electron, так как предоставляет API для доступа к функциям на уровне операционной системы, таким как файловая система, сеть и т. д."
    },
    "3": {
        "question": "Как вы управляете пакетами в вашем проекте на node.js?",
        "answer": "Это можно управлять с помощью ряда инструментов установки пакетов и их файлов конфигурации соanswerственно. Из них большинство использует npm или yarn. Оба предоставляют почти все библиотеки JavaScript с расширенными возможностями контроля конфигураций, специфичных для среды. Для поддержания версий библиотек, установленных в проекте, мы используем файлы package.json и package-lock.json, чтобы не было проблем с переносом этого приложения в другую среду."
    },
    "4": {
        "question": "Как Node.js лучше других наиболее популярно используемых фреймворков?",
        "answer": "* Node.js обеспечивает простоту в разработке из-за своего неблокирующего ввода-вывода и модели событийного выполнения, что приводит к короткому времени answerа и параллельной обработке, в отличие от других фреймворков, где разработчики должны управлять потоками. \n* Он работает на движке chrome v8, написанном на c++, и обладает высокой производительностью с постоянным улучшением. \n* Также, поскольку мы будем использовать JavaScript как на клиентской, так и на серверной стороне, разработка будет намного быстрее. \n* И, наконец, существует множество библиотек, чтобы нам не приходилось пересоздавать велосипед."
    },
    "5": {
        "question": "Объясните шаги, как управление потоком управляет вызовами функций?",
        "answer": "* Контроль порядка выполнения\n* Сбор данных\n* Ограничение параллелизма\n* Вызов следующего шага в программе."
    },
    "6": {
        "question": "Какие часто используемые функции времени в Node.js?",
        "answer": "* setTimeout/clearTimeout - это используется для задержки выполнения кода.\n* setInterval/clearInterval - это используется для многократного выполнения блока кода.\n* setImmediate/clearImmediate - любая функция, переданная как аргумент setImmediate(), является обратным вызовом, который выполняется в следующей итерации цикла событий.\n* process.nextTick - оба setImmediate и process.nextTick кажутся делающими одно и то же, однако вы можете предпочесть одно перед другим в зависимости от срочности вашего обратного вызова. "
    },
    "7": {
        "question": "Какие преимущества использования обещаний перед обратными вызовами?",
        "answer": "Основное преимущество использования обещания заключается в том, что вы получаете объект, который решает действие, которое должно быть выполнено после завершения асинхронной задачи. Это обеспечивает более управляемый код и избегает ада обратных вызовов."
    },
    "8": {
        "question": "Что такое fork в node JS?",
        "answer": "Форк в общем используется для порождения дочерних процессов. В node он используется для создания нового экземпляра движка v8 для запуска нескольких рабочих процессов для выполнения кода."
    },
    "9": {
        "question": "Почему Node.js однопоточен?",
        "answer": "Node.js был создан явно как эксперимент по асинхронной обработке. Это было сделано для проверки новой теории асинхронной обработки на одном потоке вместо существующей потоковой реализации масштабирования через различные фреймворки."
    },
    "10": {
        "question": "Как создать простой сервер в Node.js, который возвращает Hello World?",
        "answer": "var http = require('http');\nhttp.createServer(function (request, response) {\nresponse.writeHead(200, {'Content-Type': 'text/plain'});\nresponse.end('Hello World\n');\n}).listen(3000);\n"
    },
    "11": {
        "question": "Сколько типов функций API существует в Node.js?",
        "answer": "Существует два типа функций API:\n\n* Асинхронные, неблокирующие функции - в основном операции ввода-вывода, которые могут быть выделены из основного цикла.\n* Синхронные, блокирующие функции - в основном операции, которые влияют на процесс, работающий в основном цикле."
    },
    "12": {
        "question": "Что такое REPL?",
        "answer": "REPL в Node.js означает Read, Eval, Print и Loop, что дальше означает оценку кода на лету."
    },
    "13": {
        "question": "Перечислите два аргумента, которые принимает async.queue на входе?",
        "answer": "* Функция задания\n* Значение параллелизма"
    },
    "14": {
        "question": "Какова цель module.exports?",
        "answer": "Он используется для экспорта функций определенного модуля или файла для использования в другом месте в проекте. Это можно использовать для инкапсуляции всех подобных функций в файле, что дальше улучшает структуру проекта."
    },
    "15": {
        "question": "Какие инструменты могут использоваться для обеспечения согласованного стиля кода?",
        "answer": "ESLint можно использовать с любой IDE для обеспечения согласованного стиля кодирования, что дальше помогает поддерживать кодовую базу."
    },
    "16": {
        "question": "Что такое event-loop в Node JS?",
        "answer": "Все, что асинхронно, управляется циклом событий с использованием очереди и слушателя.\n\nкогда асинхронная функция должна быть выполнена (или I/O), основной поток отправляет ее в другой поток, позволяя v8 продолжать выполнение основного кода. Цикл событий включает различные фазы с определенными задачами, такими как таймеры, ожидающие обратные вызовы, простой или подготовка, опрос, проверка, обратные вызовы закрытия с различными очередями FIFO. Также между итерациями он проверяет асинхронный ввод-вывод или таймеры и чисто завершает работу, если их нет."
    },
    "17": {
        "question": "В чем разница между process.nextTick() и setImmediate()?",
        "answer": "Оба могут использоваться для перехода в асинхронный режим работы с помощью слушателей функций. \n\nprocess.nextTick() устанавливает обратный вызов для выполнения, но setImmediate помещает обратный вызов в очередь для выполнения. Таким образом, цикл событий работает следующим образом\n\ntimers–>pending callbacks–>idle,prepare–>connections(poll,data,etc)–>check–>close callbacks\n\nВ этом process.nextTick() метод добавляет функцию обратного вызова в начало следующей очереди событий, а метод setImmediate() размещает функцию в фазе проверки следующей очереди событий."
    },
    "18": {
        "question": "Как Node.js преодолевает проблему блокировки операций ввода-вывода?",
        "answer": "Поскольку у node есть цикл событий, который можно использовать для обработки всех операций ввода-вывода асинхронным образом без блокировки основной функции. \n\nТак, например, если нужен какой-то сетевой вызов, он будет запланирован в цикле событий, а не в основном потоке (однопоточном). И если есть несколько таких вызовов ввода-вывода, каждый из них будет поставлен в очередь для выполнения отдельно (не в главном потоке). \n\nТаким образом, даже если у нас однопоточный JS, операции ввода-вывода обрабатываются в неблокирующем режиме."
    },
    "19": {
        "question": "Что такое потоки в node.js?",
        "answer": "Потоки - это экземпляры EventEmitter, которые могут использоваться для работы со стриминговыми данными в Node.js. Их можно использовать для обработки и манипулирования потоковыми большими файлами (видео, mp3 и т. д.) через сеть. Они используют буферы как временное хранилище.\n\nВ основном существует четыре типа потоков:\n* Writable: потоки, в которые можно писать данные (например, fs.createWriteStream()).\n* Readable: потоки, из которых можно читать данные (например, fs.createReadStream()).\n* Duplex: потоки, которые являются и Readable, и Writable (например, net.Socket).\n* Transform: Дуплексные потоки, которые могут модифицировать или преобразовывать данные при записи и чтении (например, zlib.createDeflate())."
    },
    "20": {
        "question": "Что такое буферы в node.js?",
        "answer": "В целом, буферы - это временная память, которая в основном используется потоком для удержания данных до их использования. Буферы представляют собой последовательность байтов фиксированной длины. Они вводятся с дополнительными возможностями использования, чем Uint8Array в JavaScript, и в основном используются для представления последовательности байтов фиксированной длины. Они также поддерживают устаревшие кодировки, такие как ASCII, utf-8 и т. д. Это фиксированная (неизменяемая) выделенная память вне v8."
    },
    "21": {
        "question": "Что такое middleware?",
        "answer": "Middleware находится между вашим запросом и бизнес-логикой. Он в основном используется для захвата журналов и включения ограничения скорости, маршрутизации, аутентификации, в основном все, что не является частью бизнес-логики. Существуют также сторонние промежуточные программы, такие как body-parser, и вы можете написать собственные промежуточные программы для конкретного случая использования."
    },
    "22": {
        "question": "Что такое паттерн Reactor в Node.js?",
        "answer": "Паттерн Reactor снова является шаблоном для неблокирующих операций ввода-вывода. Но в общем, он используется в любой событийно-управляемой архитектуре. \n\nВ нем два компонента: 1. Reactor 2. Обработчик.\nReactor: Его задача - отправлять событие I/O соanswerствующим обработчикам\nОбработчик: Его задача - фактически работать с этими событиями"
    },
    "23": {
        "question": "Почему следует разделять приложение Express и сервер?",
        "answer": "Сервер отвечает за инициализацию маршрутов, промежуточного программного обеспечения и другой логики приложения, тогда как в приложении содержится вся бизнес-логика, которая будет обслуживаться маршрутами, инициированными сервером. Это обеспечивает инкапсуляцию и разделение бизнес-логики и логики приложения, что делает проект более читаемым и поддерживаемым."
    },
    "24": {
        "question": "Для Node.js, почему Google использует движок V8?",
        "answer": "Ну, есть ли другие варианты? Да, конечно, у нас есть Spidermonkey от Firefox, Chakra от Edge, но v8 от Google - самый совершенный (поскольку он open-source, то здесь огромное сообщество помогает в разработке функций и исправлении ошибок) и быстрый (поскольку он написан на c++), который у нас есть до сих пор в качестве движка JavaScript и WebAssembly. И его можно использовать на практически каждом известном компьютере."
    },
    "25": {
        "question": "Опишите коды завершения Node.js?",
        "answer": "Коды завершения дают представление о том, как процесс завершился/причина завершения. \n\nНекоторые из них:\n\n* Необработанное фатальное исключение - (код - 1) - Произошло исключение, которое не было обработано\n* Неиспользуемый - (код - 2) - Этот код зарезервирован для bash\n* Фатальная ошибка - (код - 5) - Произошла ошибка в V8 с выводом stderr описания\n* Внутренний сбой обработчика исключений времени выполнения - (код - 7) - Произошло исключение при вызове функции загрузки\n* Внутреннее оценочное сбой JavaScript - (код - 4) - Произошло исключение, когда процесс загрузки не смог вернуть значение функции при оценке."
    },
    "26": {
        "question": "Объясните концепцию stub в Node.js?",
        "answer": "Stub используется при написании тестов, которые являются важной частью разработки. Он заменяет всю функцию, которая тестируется.  \n\nЭто помогает в ситуациях, когда нам нужно тестировать:\n* Внешние вызовы, которые делают тесты медленными и сложными в написании (например, HTTP-вызовы/вызовы БД)\n* Запуск различных результатов для части кода (например, что произойдет, если будет сгенерирована ошибка/если все пройдет успешно)"
    },
    "27": {
        "question": "Что такое EventEmitter в Node.js?",
        "answer": "EventEmitter - это класс Node.js, который включает все объекты, способные генерировать события. Это можно сделать, присоединив именованные события, которые генерируются объектом, с использованием функции eventEmitter.on(). Таким образом, когда этот объект генерирует событие, прикрепленные функции вызываются синхронно."
    },
    "28": {
        "question": "Как улучшить производительность Node.js с помощью кластеризации?",
        "answer": "Приложения Node.js работают на одном процессоре, что означает, что по умолчанию они не используют многопроцессорные системы. Режим кластера используется для запуска нескольких процессов Node.js, тем самым создавая несколько экземпляров цикла событий. Когда мы начинаем использовать кластер в приложении Node.js, за кадром создаются несколько процессов Node.js, но также есть родительский процесс, называемый менеджером кластеров, который отвечает за мониторинг состояния каждого индивидуального экземпляра нашего приложения."
    },
    "29": {
        "question": "Что такое WASI и для чего оно вводится?",
        "answer": "WebAssembly предоставляет реализацию спецификации WebAssembly System Interface через API WASI в Node.js, реализованное с использованием класса WASI. Введение WASI было осуществлено с учетом возможности использования основной операционной системы через набор функций, подобных POSIX, тем самым дополнительно позволяя приложению использовать ресурсы более эффективно и функции, требующие доступа на уровне системы."
    },
    "30": {
        "question": "В чем разница между синхронными и асинхронными функциями?",
        "answer": "Синхронные функции в основном используются для операций ввода-вывода. Они мгновенно предоставляют answer на перемещение данных на сервере и следуют требованиям данных. Если answerа нет, API сгенерирует ошибку.\n\nС другой стороны, асинхронные функции, как следует из названия, работают на основе отсутствия синхронизации. Здесь HTTP-запросы при отправке не будут ожидать начала answerа. answerы на любые предыдущие запросы будут непрерывными, даже если сервер уже получил answer."
    },
    "31": {
        "question": "Какие асинхронные задачи должны выполняться в цикле событий?",
        "answer": "Вот некоторые задачи, которые можно выполнять асинхронно с использованием цикла событий:\n\n* Блокирующие отправки запросов\n* Операции с высокими вычислительными требованиями\n* Операции ввода-вывода в реальном времени"
    },
    "32": {
        "question": "Каков порядок выполнения инструкций управления потоком?",
        "answer": "Вот порядок, в котором используются инструкции управления потоком для обработки вызовов функций:\n\n* Обработка выполнения и очередь\n* Сбор и хранение данных\n* Обработка параллелизма и ограничение\n* Выполнение следующего участка кода"
    },
    "33": {
        "question": "Какие входные аргументы принимает асинхронная очередь?",
        "answer": "У асинхронной очереди есть два основных аргумента. Они следующие:\n\n* Значение параллелизма\n* Функция задачи"
    },
    "34": {
        "question": "Каков основной причиной использования событийной модели в Node.js?",
        "answer": "Событийная модель в Node.js используется для преодоления проблем, возникающих при использовании блокирующих операций в канале ввода-вывода.\n\nДалее в этом блоге, посвященном questionам Node.js, вам нужно будет понять, как можно импортировать библиотеки в Node.js."
    },
    "35": {
        "question": "Что означает программирование, основанное на событиях в Node.js?",
        "answer": "Программирование, основанное на событиях, - это техника, при которой выполнение рабочего процесса программы в основном контролируется появлением событий из внешних программ или других источников.\nАрхитектура, основанная на событиях, состоит из двух сущностей, а именно:\n* Обработка событий\n* Выбор событий"
    },
    "36": {
        "question": "Каковы реализации безопасности, присутствующие в Node.js?",
        "answer": "Вот некоторые важные реализации безопасности:\n\n* Протоколы обработки ошибок\n* Потоки аутентификации"
    },
    "37": {
        "question": "Что означает тестовая пирамида?",
        "answer": "Тестовая пирамида - это методология, которая используется для обозначения количества тестов, выполненных в модульном тестировании, интеграционном тестировании и совместном тестировании (в таком порядке). Это поддерживается для обеспечения того, что будет выполнено достаточное количество тестов для конечной разработки проекта."
    },
    "38": {
        "question": "Что такое Libuv?",
        "answer": "Libuv - это широко используемая библиотека, присутствующая в Node.js. Она используется для дополнения асинхронной функциональности ввода-вывода Node.js. Она была разработана внутри компании и используется вместе с такими системами, как Luvit, Julia и другими.\n\nВот некоторые из особенностей Libuv:\n* Обработка событий файловой системы\n* Создание и обработка дочерних процессов\n* Асинхронные UDP и TCP сокеты\n* Асинхронная обработка и операции с файлами"
    },
    "39": {
        "question": "Что такое глобальные объекты в Node.js?",
        "answer": "Глобальные объекты - это объекты с областью видимости, доступной во всех модулях приложения Node.js. Не будет необходимости включать объекты в каждый модуль. Один из объектов объявлен как глобальный. Таким образом, это делается для обеспечения доступа к функциям, строкам или объектам во всем приложении."
    },
    "40": {
        "question": "В чем разница между readFile и createReadStream в Node.js?",
        "answer": "* readFile: Это используется для асинхронного чтения всего содержимого указанного файла. Весь контент будет считан в память, прежде чем пользователи смогут получить к нему доступ.\n* createReadStream: Это используется для разделения файла на более мелкие части и их последующего чтения. Размер части по умолчанию составляет 64 КБ, и его можно изменить по мере необходимости."
    },
    "41": {
        "question": "Какова цель модуля crypto в Node.js?",
        "answer": "Модуль crypto в Node.js используется для предоставления пользователям криптографических функций. Он предоставляет им большое количество оболочек для выполнения различных операций, таких как шифрование, дешифрование, подпись и хеширование."
    },
    "42": {
        "question": "Что такое passport в Node.js?",
        "answer": "Passport - это широко используемое промежуточное ПО, присутствующее в Node.js. Оно применяется в основном для аутентификации и легко интегрируется в любое веб-приложение, основанное на Express.js.\n\nСоздавая каждое приложение, требуется уникальные механизмы аутентификации. Это предоставляется в виде отдельных модулей с использованием passport, и становится легким назначение стратегий приложениям в зависимости от требований, тем самым избегая каких-либо зависимостей."
    }
}