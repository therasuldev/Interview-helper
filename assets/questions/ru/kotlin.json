{
    "1": {
        "question": "Особенности Kotlin",
        "answer": "Kotlin поставляется со множеством функций, которые сделали жизнь разработчиков проще. Выделение нескольких привлекательных особенностей Kotlin, которые помогут вам лучше понять этот язык программирования-\n\n1. Компактный код- Kotlin известен как объектно-ориентированный язык программирования с меньшим количеством строк кода по сравнению с Java. Эта функция делает его отличным выбором для разработчиков программного обеспечения.\n\n2. Открытый исходный код- Kotlin объединяет атрибуты ООП и функционального программирования. Он известен как открытый исходный код для Android и использует JVM.\n\n3. Легко понять- Кодирование на Kotlin простое, что делает его читаемым и понятным. Не забывайте также, что это помогает улучшить производительность разработки Android.\n\n4. Много расширений- Этот код может поддерживать различные расширительные функции без изменения кода. Это помогает улучшить существующий код и сделать его более эффективным.\n\n5. Легко объединить- Можно быстро перейти от кода Java к коду Kotlin, не думая много, поскольку оба кода можно использовать вместе. Другими словами, если у вас есть небольшое количество знаний объектно-ориентированного программирования, переход к разработке на Kotlin для вас не должен составить большую проблему.\n\n6. Экономия затрат- Kotlin поддерживает высокоэффективную и экономически выгодную технику, известную как Smart Cast. Эта техника помогает снизить стоимость приложения и делает программирование более эффективным.\n\n7. Легкость обучения- Kotlin предлагает простой язык кода, который упрощает весь процесс и делает общий опыт более простым и эффективным. Этот код легко учить для разработчиков по сравнению с другими языками."
    },
    "2": {
        "question": "Каковы преимущества Kotlin по сравнению с Java?",
        "answer": "* Легкий процесс- В Java нужно создавать геттеры и сеттеры для каждого объекта. Более того, необходимо написать hashCode и equals. Однако в языке программирования Kotlin все это берется на себя классами, что упрощает процесс.\n\n* Переписывание метода- Если вы используете Java, то для каждой переменной необходимо переписывать/копировать методы геттера и сеттера, что занимает много времени. В Kotlin переписывание занимает намного меньше времени.\n\n* Поддержка расширений- В Java нельзя использовать расширительные функции. Однако в Kotlin сильно поддерживаются расширительные функции, что делает весь процесс и язык кода более ясными.\n\n* Меньше ошибок- В Kotlin шансы на ошибки меньше, чем в Java."
    },
    "3": {
        "question": "Какова целевая платформа Kotlin? Как достигается совместимость Kotlin и Java?",
        "answer": "Целевая платформа Kotlin - это Java Virtual Machine. Да, совместимость Kotlin и Java возможна, так как оба производят байт-код при компиляции. Из-за этой причины возможно вызывать код Kotlin из Java и наоборот."
    },
    "4": {
        "question": "Как отличить объявление val от var?",
        "answer": "Переменные val не могут быть изменены. Они рассматриваются как окончательные модификаторы в Java. С другой стороны, var может быть переназначен с тем же типом данных."
    },
    "5": {
        "question": "Можно ли преобразовать String в Int?",
        "answer": "Да, с помощью метода toInt() можно преобразовать String в Int."
    },
    "6": {
        "question": "Что такое оператор Элвиса?",
        "answer": "Оператор Элвиса рассматривается как защита значения. Он помогает безопасно извлечь значение из Nullable. Его можно определить как ?: для типа, допускающего значение null."
    },
    "7": {
        "question": "Что такое безопасность от нулевого значения (Null Safety)?",
        "answer": "Безопасность от нулевого значения относится к инициализации значения 'null', чтобы переменная содержала null для возможного выполнения. С помощью безопасности от нулевого значения все ошибки времени выполнения null-dereference будут отражены на этапе компиляции."
    },
    "8": {
        "question": "Что такое Nullable-типы в Kotlin?",
        "answer": "Вот следующие Nullable-типы в Kotlin: String?, Int?, Float?."
    },
    "9": {
        "question": "Можем ли мы использовать примитивные типы, такие как int, float и double в Kotlin?",
        "answer": "На начальном уровне нельзя использовать примитивные типы. Но их можно использовать при компиляции в JVM байт-код."
    },
    "10": {
        "question": "Какова точка входа в программу на Kotlin?",
        "answer": "Основная функция считается точкой входа в программу на Kotlin. В этом языке программирования можно игнорировать центральную часть класса. Позднее строки, переданные в команду Array<String>, используются для извлечения аргументов командной строки."
    },
    "11": {
        "question": "В чем различие между const и val?",
        "answer": "Нельзя использовать const с переменной типа var или отдельно. Const не разрешается для локальных переменных. Свойства val определены на этапе выполнения. Добавление модификатора const к val может сделать его временной константой на этапе компиляции."
    },
    "12": {
        "question": "Как определить, что функция была объявлена?",
        "answer": "Тип возвращаемого значения функции указывается после символа : \n\nНапример:\n\nfun sumOf(a: Int, b: Int): Int{\n\nreturn a + b}"
    },
    "13": {
        "question": "Как отличить операторы == и === в Kotlin?",
        "answer": "== используется для определения равенства значений. === используется для проверки равенства ссылок."
    },
    "14": {
        "question": "Какие существуют модификаторы видимости в Kotlin?",
        "answer": "Модификаторы видимости в Kotlin: Public, Internal, Private и Protected."
    },
    "15": {
        "question": "Какой модификатор видимости является модификатором видимости по умолчанию?",
        "answer": "По умолчанию модификатор видимости - public."
    },
    "16": {
        "question": "Определите типы конструкторов в Kotlin.",
        "answer": "Конструкторы в Kotlin могут быть определены в двух типах - Основной и Вторичный.\n\nОсновной: Основные конструкторы выделяются в заголовках класса. Они не могут содержать логики. Поэтому в каждом классе может быть только один основной конструктор.\n\nВторичный: Вторичные конструкторы определены в теле класса. Они могут содержать логику. Можно указать более одного вторичного конструктора."
    },
    "17": {
        "question": "Определите блок init в Kotlin?",
        "answer": "init идентифицируется как блок инициализации в Kotlin. Он может быть выполнен только после того, как основной конструктор был создан. Однако, если кто-то вызывает вторичный конструктор, он начнет работать после основного, следуя цепочке."
    },
    "18": {
        "question": "Как работает интерполяция строк в Kotlin?",
        "answer": "Интерполяция строк используется для вычисления строковых шаблонов. Для вставки переменных внутрь строки используется символ $."
    },
    "19": {
        "question": "Определите типы аргументов в конструкторе?",
        "answer": "Аргументы конструктора по умолчанию устанавливаются как val и var."
    },
    "20": {
        "question": "Идентифицируете ли вы 'new' как ключевое слово в Kotlin?",
        "answer": "Нет, в Kotlin нет слова 'new'. Однако его можно найти в Java."
    },
    "21": {
        "question": "Как мы можем создать экземпляр объекта класса в Kotlin?",
        "answer": "Вот быстрый пример того, как мы можем это сделать:\n\nclass A\n\nvar a = A()\n\nVal new = A()"
    },
    "22": {
        "question": "Что вы понимаете под объектами-компаньонами в Kotlin?",
        "answer": "В других языках программирования, таких как Java, ключевое слово static используется для объявления членов/имени класса. В Kotlin нет ключевого слова static, то есть для достижения функциональности статических методов используется объект-компаньон. Объект-компаньон также известен как Расширение объекта."
    },
    "23": {
        "question": "В чем разница между ключевыми словами Open и Public в Kotlin?",
        "answer": "Open означает открытый для расширения. В Java методы могут быть переопределены по умолчанию. В Kotlin важно использовать доступную форму, которую можно переопределить, но это не делается по умолчанию.\n\nЕсли в Kotlin не указан модификатор видимости, по умолчанию используется public. Это означает, что объявления будут доступны везде в программе."
    },
    "24": {
        "question": "Что вы понимаете под ключевым словом \"when\" в контексте Kotlin?",
        "answer": "Ключевое слово \"when\" относится к заменам. Оно используется для замены оператора switch в других языках, таких как Java. После выполнения определенного условия должен выполняться определенный блок кода. \n\nВнутри этого выражения оно сравнивает все ветви по очереди. Цель - найти соответствие. Как только первое соответствие будет найдено, оно переходит к завершению блока when и сосредотачивается на выполнении кода непосредственно."
    },
    "25": {
        "question": "Как вы отличаете lazy от lateinit?",
        "answer": "* Оба атрибута известны своей способностью задерживать инициализацию свойства в Kotlin. \n\n* Lateinit считается модификатором, используемым с var. Он используется для установки значения var в более поздний момент.\n\nМетод lazy или лямбда-выражение разработаны только для val. Значение будет создано во время выполнения, когда это потребуется."
    },
    "26": {
        "question": "Имеет ли Kotlin ключевое слово static?",
        "answer": "Нет, в Kotlin вы не найдете ключевое слово static. Чтобы создать статическое ключевое слово, нужно использовать объект-компаньон."
    },
    "27": {
        "question": "Что лучше использовать: val mutableList или var immutableList в Kotlin?",
        "answer": "Изменяемые и неизменяемые списки улучшают ясность проектирования, так как заставляют разработчика думать и уточнять цель коллекции. Изменяемые списки используются, если коллекция будет изменяться как часть проектирования, а неизменяемые списки, если модель предназначена для просмотра. \n\nVal и var, снова, имеют конкретные цели. Они определяют, как должно обрабатываться значение или ссылка переменной. Var используется, когда значение или ссылку можно изменить в любой момент, и val, когда значение или ссылку переменной можно присвоить один раз и потом не изменять. \n\nЧасто предпочитают неизменяемые списки, потому что они способствуют функциональному программированию, где состояние передается следующей функции. Таким образом, новое состояние создается на основе предыдущего, а не изменяется. \n\nТакже часто проще понять и отлаживать программное обеспечение. Неизменяемые ресурсы не вызывают состояний гонки, потому что в многопоточных системах не требуется доступа к записи. \n\nНо есть и недостатки. Копирование больших коллекций для добавления или удаления одного элемента дорого для неизменяемых списков. Код также может стать более сложным, когда часто нужно изменять одиночные поля."
    },
    "28": {
        "question": "Определите корутины в Kotlin.",
        "answer": "В Kotlin нет ключевых слов async и await. Kotlinx.coroutines - это богатая библиотека для корутин с примитивами, поддерживающими корутины на высоком уровне. Корутины в Kotlin предоставляют API для написания асинхронного кода последовательно. Они похожи на легковесные потоки, потому что не выделяют новые потоки при создании. \n\nКорутины могут быть приостановлены и возобновлены во время выполнения. Можно иметь долгосрочное задание, выполняемое по одному."
    },
    "29": {
        "question": "Как использование запечатанных классов лучше, чем перечисления?",
        "answer": "Запечатанные классы имеют различные типы подклассов и содержат состояние. Подклассы, расширяющие запечатанные классы, должны быть вложенными классами или объявлены в том же файле, что и запечатанный класс."
    }
}